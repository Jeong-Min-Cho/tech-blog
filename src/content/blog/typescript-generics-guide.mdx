---
title: "Mastering TypeScript Generics: A Practical Guide"
description: "Understand TypeScript generics from the ground up with real-world examples. Learn how to write flexible, reusable, and type-safe code."
pubDate: 2024-01-10
tags: ["typescript", "javascript", "programming"]
featured: true
---

TypeScript generics are one of the most powerful features of the language, yet many developers find them intimidating. Let's break them down with practical examples you can use today.

## What Are Generics?

Generics allow you to write code that works with multiple types while maintaining type safety. Think of them as "type parameters" - placeholders for types that get filled in later.

```typescript
// Without generics - only works with numbers
function firstNumber(arr: number[]): number | undefined {
  return arr[0];
}

// With generics - works with any type!
function first<T>(arr: T[]): T | undefined {
  return arr[0];
}

const num = first([1, 2, 3]);      // type: number | undefined
const str = first(['a', 'b']);     // type: string | undefined
```

## Basic Generic Syntax

The `<T>` is a type parameter. By convention, we use single uppercase letters:

- `T` - Type
- `K` - Key
- `V` - Value
- `E` - Element

```typescript
// Generic function
function identity<T>(value: T): T {
  return value;
}

// Generic interface
interface Box<T> {
  value: T;
}

// Generic type alias
type Pair<T, U> = {
  first: T;
  second: U;
};
```

## Constraining Generic Types

Sometimes you need to restrict what types can be used. Use `extends` to add constraints:

```typescript
// T must have a length property
function logLength<T extends { length: number }>(item: T): void {
  console.log(item.length);
}

logLength("hello");      // OK - strings have length
logLength([1, 2, 3]);    // OK - arrays have length
logLength({ length: 5 }); // OK - object has length
logLength(123);          // Error! numbers don't have length
```

## Real-World Examples

### API Response Wrapper

```typescript
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
  timestamp: Date;
}

interface User {
  id: number;
  name: string;
  email: string;
}

async function fetchUser(id: number): Promise<ApiResponse<User>> {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
}

// Usage - TypeScript knows data is User
const response = await fetchUser(1);
console.log(response.data.name); // Fully typed!
```

### Generic React Component Props

```typescript
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
  keyExtractor: (item: T) => string;
}

function List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {
  return (
    <ul>
      {items.map(item => (
        <li key={keyExtractor(item)}>
          {renderItem(item)}
        </li>
      ))}
    </ul>
  );
}

// Usage
<List
  items={users}
  renderItem={(user) => user.name}  // TypeScript knows user is User
  keyExtractor={(user) => user.id.toString()}
/>
```

### Type-Safe Event Emitter

```typescript
type EventMap = {
  login: { userId: string };
  logout: undefined;
  error: { message: string; code: number };
};

class TypedEventEmitter<T extends Record<string, unknown>> {
  private listeners = new Map<keyof T, Set<Function>>();

  on<K extends keyof T>(event: K, callback: (data: T[K]) => void): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event)!.add(callback);
  }

  emit<K extends keyof T>(event: K, data: T[K]): void {
    this.listeners.get(event)?.forEach(cb => cb(data));
  }
}

const emitter = new TypedEventEmitter<EventMap>();

// Fully typed!
emitter.on('login', (data) => {
  console.log(data.userId); // TypeScript knows this exists
});

emitter.emit('error', { message: 'Oops', code: 500 }); // Type-checked
```

## Utility Types Using Generics

TypeScript includes powerful built-in utility types:

```typescript
interface User {
  id: number;
  name: string;
  email: string;
  password: string;
}

// Make all properties optional
type PartialUser = Partial<User>;

// Make all properties required
type RequiredUser = Required<PartialUser>;

// Pick specific properties
type UserCredentials = Pick<User, 'email' | 'password'>;

// Omit specific properties
type PublicUser = Omit<User, 'password'>;

// Make all properties readonly
type ReadonlyUser = Readonly<User>;
```

## Common Patterns

### Factory Function

```typescript
function createState<T>(initial: T) {
  let state = initial;

  return {
    get: () => state,
    set: (newState: T) => { state = newState; }
  };
}

const counter = createState(0);
counter.set(5);        // OK
counter.set("hello");  // Error! Expected number
```

### Generic with Default Type

```typescript
interface Container<T = string> {
  value: T;
}

const stringContainer: Container = { value: "hello" };
const numberContainer: Container<number> = { value: 42 };
```

## Tips for Success

1. **Start simple** - Don't over-engineer. Use generics when you actually need flexibility.
2. **Name meaningfully** - Use `TItem` or `TUser` instead of just `T` when it improves clarity.
3. **Add constraints** - Use `extends` to catch errors early.
4. **Leverage inference** - Let TypeScript infer types when possible.

## Conclusion

Generics are essential for writing reusable, type-safe TypeScript code. Start with simple cases and gradually tackle more complex patterns. The key is practice!

Remember: if you're repeating similar code for different types, generics might be the solution.
